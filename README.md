Overview 

This script is a Password Manager Simulation written in Python. It uses MySQL for persistence and implements basic security controls:  
    A 4-digit PIN and a patched Two-Factor Authentication (2FA) mechanism using the TOTP (Time-based One-Time Password) algorithm via the pyotp library. 

The key operations are centered around CRUD (Create, Read, Update, Delete) for user credentials, with an additional focus on Password Strength Analysis using entropy calculation. 

 

Security Features Explained 

    1. Password Entropy and Strength Analysis 

        The script uses a robust method to measure password strength called Shannon Entropy, which is a logarithmic measure of randomness. 
        Character Set Size (C): The get_charset_size function determines the total number of unique characters available to the attacker. 
            It checks for the presence of four common character groups: lowercase (26), uppercase (26), digits (10), and punctuation (32). 
            Crucially, it includes an extra 100 for characters outside the ASCII range (ord(c) > 127), accounting for international or extended characters. 

        Example: A password with only lowercase and digits has $C = 26 + 10 = 36$. 

        Entropy Calculation (E): The calculate_entropy function applies the formula: 

        E = L x log_2 (C)     [log (base 2) c] 

            Where L is the password length. Entropy is measured in bits. A higher bit count means exponentially more effort is required for a brute-force attack. 

        Thresholds: The strength_rating function uses common entropy benchmarks: 

            Weak: E < 28$ bits 

            Moderate: 28 \le E < 36$ bits 

            Strong: 36 \le E < 60$ bits 

            Very Strong: E \ge 60$ bits 

        It also immediately flags any password that matches a common entry in the COMMON set as "Very Weak." 

    2. Two-Factor Authentication (2FA) Flow 

        2FA provides a critical defence against password/PIN leakage by requiring "something you know" (the PIN) and "something you have" (the OTP code from an authenticator app). 

        Trigger Points: The two most sensitive functions, View Password (view_password) and View Strength (psc), require 2FA after the local PIN check. 

        The verify_otp_for_user Function: 

            It first retrieves the user's pin and secret_key from a separate, assumed-to-exist user_2fa.twofa table (defined by TWOFA_DB). 

            It verifies the user-provided PIN against the stored PIN from the 2FA table (this is a redundant PIN check, as the main app already did this, but it reinforces the 2FA data integrity). 

            It prompts the user for the OTP code. 

            It initializes a pyotp.TOTP object using the stored secret_key (the shared secret) and digits=4 (defining the length of the code). 

            totp.verify(otp_input) checks if the user's input matches the code generated by the pyotp library for the current 30-second time window. 

 

Application Architecture and Database 
User table:

     Column,                        Data Type,                          Constraint,                                 Description
    id,                             INT,                            "PRIMARY KEYAUTO_INCREMENT",                Unique user identifier.
    username,                       VARCHAR(50),                    UNIQUE,                                     User's unique login name.
    pin,                            CHAR(4),                                                           The 4-digit PIN for access control.

Password Table:

     Column,                 Data Type,                      Constraint,                                             Description
    id,                     INT,                            "PRIMARY KEY, AUTO_INCREMENT",                      Unique password record identifier.
    user_id,                INT,                             "FOREIGN KEY to users.id, ON DELETE CASCADE",      Links the password to its owner.
    website,                VARCHAR(200),                                                                       The name/URL of the website.
    password,               VARCHAR(200),                                                                       The plaintext password for the website.


Core Function Flow 

    Initialization: main() establishes the connection and calls create_database_and_tables to ensure the structure is ready. 

    store_user: Inserts a new user and their PIN. It uses re.fullmatch(r'\d{4}', pin) to ensure the PIN is exactly four digits. 

    view_password: 

        Fetches the user and their stored PIN. 

        Requires the user to enter the correct PIN. 

        Crucially, it opens a second database connection (conn2, cursor2 = connect_to_database()) solely to run the verify_otp_for_user function, which connects to the external user_2fa database structure. This nested connection ensures the main connection stays focused on the password manager's primary database (PW_DB). 

        If 2FA passes, the password is retrieved and displayed. 

Security Concerns and Improvements

    Missing Hashing/Encryption: In a real application, the pin, the password, and the secret_key must be securely stored. 

    Pins/Passwords: Should be stored using a strong hashing algorithm (e.g., Argon2, bcrypt) instead of plain text. 

    Passwords (Vault): The saved website passwords should be encrypted using a key derived from the user's master PIN/password (e.g., using AES-256 in CBC mode). 

    Insecure 2FA PIN: The script relies on the 4-digit PIN for local access. This is a very weak access control. A strong master password should be used instead. 